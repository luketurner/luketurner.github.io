<!DOCTYPE html>
<html>
<head>

		
	<meta charset="utf-8">
	<title>Write Yourself a&nbsp;Scheme - Luke Turner</title>
	<meta name="author" content="Luke Turner">
	
		<link href="/theme/css/style.min.css?e78f7ca8" rel="stylesheet" >
	
	<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
		<script src="/theme/js/base.min.js?07bbe624" type="text/javascript"></script>





		
    <script type= "text/javascript">
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script>

</head>
<body>
	<div id="wrapper">
		<header>
			<h1><a href="/">Luke Turner</a></h1>
            <h2>&mdash; Vēnī, vīdī, cōgitāvī</h2>

		</header>
		<div id="sidebar">

		<h2>
			<a href="/Programming/Write%20Yourself%20a%20Scheme" rel="bookmark" title="Permalink to Write Yourself a Scheme">
				Write Yourself a&nbsp;Scheme
			</a>
		</h2>
        
        <div class="date">Created Nov 08, 2013</div>
        <div class="date">Last Updated Dec 12, 2013</div>

	<nav>
		<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#about" id="id10">About</a></li>
<li><a class="reference internal" href="#exercise-notes" id="id11">Exercise Notes</a><ul>
<li><a class="reference internal" href="#chapter-3-3" id="id12">Chapter 3.3</a><ul>
<li><a class="reference internal" href="#exercise-1" id="id13">Exercise 1</a></li>
<li><a class="reference internal" href="#exercise-2" id="id14">Exercise 2</a></li>
<li><a class="reference internal" href="#exercise-4" id="id15">Exercise 4</a></li>
<li><a class="reference internal" href="#exercise-5" id="id16">Exercise 5</a></li>
<li><a class="reference internal" href="#exercise-6" id="id17">Exercise 6</a></li>
<li><a class="reference internal" href="#exercise-7" id="id18">Exercise 7</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-3-4" id="id19">Chapter 3.4</a><ul>
<li><a class="reference internal" href="#id1" id="id20">Exercise 1</a></li>
<li><a class="reference internal" href="#id2" id="id21">Exercise 2</a></li>
<li><a class="reference internal" href="#exercise-3" id="id22">Exercise 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-4-3" id="id23">Chapter 4.3</a><ul>
<li><a class="reference internal" href="#id3" id="id24">Exercise 1</a></li>
<li><a class="reference internal" href="#id4" id="id25">Exercise 2</a></li>
<li><a class="reference internal" href="#id5" id="id26">Exercise 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-5-4" id="id27">Chapter 5.4</a><ul>
<li><a class="reference internal" href="#id6" id="id28">Exercise 1</a></li>
<li><a class="reference internal" href="#id7" id="id29">Exercise 2</a></li>
<li><a class="reference internal" href="#id8" id="id30">Exercise 3</a></li>
<li><a class="reference internal" href="#id9" id="id31">Exercise 4</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion" id="id32">Conclusion</a></li>
</ul>
</div>
	</nav>
	
	        


		</div>

        <div id="content-container">
            <div id="content-inner">
<section id="content" class="body">
	<div class="entry-content">
		
<div class="section" id="about">
<h2><a class="toc-backref" href="#id10">About</a></h2>
<p>Write Yourself a Scheme is an ebook available in a few places on the Web, including as a <a class="reference external" href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">wikibook</a>, which walks you through writing a Scheme interpreter in Haskell.</p>
<p>The following are notes and solutions to the exercises, written as I progress through the book. Note that I am a Haskell noob (I’ve started this book immediately after reading <a class="reference external" href="https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard">Learn Haskell Fast and Hard</a>), so the solutions are not necessarily idiomatic, efficient, or even correct for all edge cases. However, they may serve as good launching points or samples for other noobs. Of course, I won’t post anything that straight-up doesn’t work for typical usage, and if I recognize a potential edge case failure with the code, I’ll be sure to mention it.</p>
<p>Also note that there are user-contributed answers posted in an <a class="reference external" href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Answers">appendix</a> to the wikibook edition. Those answers may be better or more correct than mine — or they may not be. I haven’t actually looked at them; that would be cheating.</p>
<p>This post is currently a heavy work in progress. I will update it as I progress through the book. Typically I do an exercise every week — nothing like waking up and diving into some functional programming to get your brain running on the weekend.</p>
</div>
<div class="section" id="exercise-notes">
<h2><a class="toc-backref" href="#id11">Exercise Notes</a></h2>
<div class="section" id="chapter-3-3">
<h3><a class="toc-backref" href="#id12">Chapter 3.3</a></h3>
<div class="section" id="exercise-1">
<h4><a class="toc-backref" href="#id13">Exercise 1</a></h4>
<p>We’re already given a definition of parseNumber that uses monad-handling functions
to deal with the Parser monad:</p>
<div class="highlight"><pre><span class="nf">parseNumber</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">read</span><span class="p">)</span> <span class="o">$</span> <span class="n">many1</span> <span class="n">digit</span>
</pre></div>
<p>Now we’re asked to implement the same function in two additional ways:</p>
<ol class="arabic simple">
<li>Using do-notation</li>
</ol>
<div class="highlight"><pre><span class="nf">parseNumber'</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber'</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
<ol class="arabic simple" start="2">
<li>Using <code>&gt;&gt;=</code>:</li>
</ol>
<div class="highlight"><pre><span class="nf">parseNumber''</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber''</span> <span class="ow">=</span> <span class="n">many1</span> <span class="n">digit</span> <span class="o">&gt;&gt;=</span>
                <span class="nf">\</span><span class="n">str</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">read</span><span class="p">)</span> <span class="n">str</span>
</pre></div>
</div>
<div class="section" id="exercise-2">
<h4><a class="toc-backref" href="#id14">Exercise 2</a></h4>
<p>One possible string parser is the following:</p>
<div class="highlight"><pre><span class="nf">parseString</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseString</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">char</span> <span class="sc">'"'</span>
                 <span class="n">str</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="n">chr</span>
                 <span class="n">char</span> <span class="sc">'"'</span>
                 <span class="n">return</span> <span class="o">$</span> <span class="kt">String</span> <span class="n">str</span>
              <span class="kr">where</span> <span class="n">chr</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'</span><span class="se">\\</span><span class="sc">'</span> <span class="o">&gt;&gt;</span> <span class="n">oneOf</span> <span class="s">"</span><span class="se">\\\"</span><span class="s">"</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">noneOf</span> <span class="s">"</span><span class="se">\"</span><span class="s">"</span>
</pre></div>
</div>
<div class="section" id="exercise-4">
<h4><a class="toc-backref" href="#id15">Exercise 4</a></h4>
<div class="highlight"><pre><span class="nf">parseNumber</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">base</span> <span class="ow">&lt;-</span> <span class="n">option</span> <span class="n">'d'</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'#'</span> <span class="o">&gt;&gt;</span> <span class="n">oneOf</span> <span class="s">"bohd"</span><span class="p">)</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">base</span> <span class="kr">of</span>
        <span class="n">'h'</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">hexDigit</span>
        <span class="n">'o'</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">octDigit</span>
        <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">notFollowedBy</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'.'</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="p">(</span><span class="n">readBase</span> <span class="n">base</span><span class="p">))</span> <span class="n">x</span>
    <span class="kr">where</span> <span class="n">readBase</span> <span class="n">'d'</span> <span class="ow">=</span> <span class="n">readDec</span>
          <span class="n">readBase</span> <span class="n">'o'</span> <span class="ow">=</span> <span class="n">readOct</span>
          <span class="n">readBase</span> <span class="n">'h'</span> <span class="ow">=</span> <span class="n">readHex</span>
</pre></div>
</div>
<div class="section" id="exercise-5">
<h4><a class="toc-backref" href="#id16">Exercise 5</a></h4>
<div class="highlight"><pre><span class="nf">parseChar</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseChar</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">char</span> <span class="sc">'#'</span>
    <span class="n">char</span> <span class="sc">'</span><span class="se">\\</span><span class="sc">'</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"space"</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="sc">' '</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"newline"</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="sc">'</span><span class="se">\n</span><span class="sc">'</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="n">alphaNum</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Char</span> <span class="n">c</span>
</pre></div>
<p>When we add this to parseExpr, we need to be careful, because now we have two things that start with an octothorp: parseNumber (e.g. <code>#d123</code>) and parseChar (e.g. <code>#\a</code>). Instead of left-factoring (a future exercise has us left-factoring the grammar), I’ve used the <code>try</code> function in <code>parseExpr</code>. That way we can "try" to see if the expression is a number; if it’s not, we don’t consume any input.</p>
</div>
<div class="section" id="exercise-6">
<h4><a class="toc-backref" href="#id17">Exercise 6</a></h4>
<div class="highlight"><pre><span class="nf">parseFloat</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseFloat</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">whole</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'.'</span>
    <span class="n">part</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">exp</span> <span class="ow">&lt;-</span> <span class="n">option</span> <span class="s">"0"</span> <span class="p">(</span><span class="n">oneOf</span> <span class="s">"eE"</span> <span class="o">&gt;&gt;</span> <span class="n">many1</span> <span class="n">digit</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">num</span> <span class="ow">=</span> <span class="n">whole</span> <span class="o">++</span> <span class="s">"."</span> <span class="o">++</span> <span class="n">part</span> <span class="o">++</span> <span class="s">"e"</span> <span class="o">++</span> <span class="n">exp</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Float</span> <span class="o">.</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">readFloat</span><span class="p">)</span> <span class="n">num</span>
</pre></div>
<p>The main interesting thing here is the line <code>exp &lt;- option "0" (oneOf "eE" &gt;&gt; many1 digit)</code>. This sets <code>exp</code> to the value of the number following the e, with 0 as the default.</p>
</div>
<div class="section" id="exercise-7">
<h4><a class="toc-backref" href="#id18">Exercise 7</a></h4>
<div class="highlight"><pre><span class="nf">parseRational</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseRational</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">top</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'/'</span>
    <span class="n">bot</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Ratio</span> <span class="p">((</span><span class="n">read</span> <span class="n">top</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">read</span> <span class="n">bot</span><span class="p">))</span>


<span class="c1">-- <span class="caps">TODO</span> fix support for decimals</span>
<span class="nf">parseComplex</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseComplex</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">real</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'+'</span>
    <span class="n">imag</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="n">'i'</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Complex</span> <span class="o">.</span> <span class="kt">Couble</span><span class="p">)</span> <span class="p">((</span><span class="n">read</span> <span class="n">real</span><span class="p">)</span> <span class="kt">:+</span> <span class="p">(</span><span class="n">read</span> <span class="n">imag</span><span class="p">))</span>
</pre></div>
<p>My Complex implementation leaves a bit to be desired — it can only handle whole-number parts. The <code>Couble</code> type constructor is a "wrapper" around Complex Double, defined like so:</p>
<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Couble</span> <span class="ow">=</span> <span class="kt">Couble</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kt">Double</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">LispVal</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="kt">String</span>
               <span class="o">...</span>
             <span class="o">|</span> <span class="kt">Complex</span> <span class="kt">Couble</span>
</pre></div>
<p>We only need to derive <code>Eq</code> once we get into chapter 6 or thereabouts.</p>
</div>
</div>
<div class="section" id="chapter-3-4">
<h3><a class="toc-backref" href="#id19">Chapter 3.4</a></h3>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id20">Exercise 1</a></h4>
<div class="highlight"><pre><span class="c1">-- handles `</span>
<span class="nf">parseBackquoted</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseBackquoted</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">char</span> <span class="sc">'`'</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">parseExpr</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">"quasiquote"</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

<span class="c1">-- handles , and ,@</span>
<span class="nf">parseUnquote</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseUnquote</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">style</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">char</span> <span class="sc">','</span> <span class="o">&gt;&gt;</span> <span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">','</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">parseExpr</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="p">(</span><span class="n">descriptor</span> <span class="n">style</span><span class="p">),</span> <span class="n">x</span><span class="p">]</span>
    <span class="kr">where</span> <span class="n">descriptor</span> <span class="sc">','</span> <span class="ow">=</span> <span class="s">"unquote"</span>
      <span class="n">descriptor</span> <span class="sc">'@'</span> <span class="ow">=</span> <span class="s">"unquote-list"</span>
</pre></div>
<p>Once again, too lazy to left-factor the grammar. I use pattern matching to check the value of <code>style</code>, which contains either <code>@</code> or <code>,</code>.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id21">Exercise 2</a></h4>
<p>I haven’t done this yet.</p>
</div>
<div class="section" id="exercise-3">
<h4><a class="toc-backref" href="#id22">Exercise 3</a></h4>
<p>I haven’t done this yet either.</p>
</div>
</div>
<div class="section" id="chapter-4-3">
<h3><a class="toc-backref" href="#id23">Chapter 4.3</a></h3>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id24">Exercise 1</a></h4>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"string?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isString</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"number?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isNumber</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"bool?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isBool</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"real?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isReal</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"char?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isChar</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"ratio?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isRational</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"complex?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isComplex</span><span class="p">),</span>
              <span class="o">...</span> <span class="p">]</span>

<span class="nf">typePredicate</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">typePredicate</span> <span class="n">op</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="n">op</span> <span class="n">val</span>
<span class="nf">typePredicate</span> <span class="n">op</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">NumArgs</span> <span class="mi">1</span> <span class="n">vals</span>

<span class="nf">isBool</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isBool</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isBool</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isString</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isString</span> <span class="p">(</span><span class="kt">String</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isString</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isChar</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isChar</span> <span class="p">(</span><span class="kt">Char</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isChar</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isNumber</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Float</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isReal</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Float</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isRational</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isRational</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isRational</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isRational</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isComplex</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="c1">-- (not true as long as parseComplex only allows whole numbers...)</span>
<span class="c1">-- isComplex (Float _) = Bool True</span>
<span class="nf">isComplex</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isComplex</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isComplex</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>
</pre></div>
<p>There are a few ways to approach this exercise… but I prefer explicitly listing the matches, because it helps in cases like isNumber, where different type constructors all indicate valid numbers.</p>
</div>
<div class="section" id="id4">
<h4><a class="toc-backref" href="#id25">Exercise 2</a></h4>
<p>Just comment out the pattern matches indicated in the exercise:</p>
<div class="highlight"><pre><span class="nf">unpackNum</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">Integer</span>
<span class="nf">unpackNum</span> <span class="p">(</span><span class="kt">Number</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">n</span>
<span class="cm">{- Removed per Ex. 4.3 #2</span>
<span class="cm">unpackNum (String n) = let parsed = reads n in</span>
<span class="cm">                          if null parsed</span>
<span class="cm">                            then throwError $ TypeMismatch "number" $ String n</span>
<span class="cm">                            else return $ fst $ parsed !! 0</span>
<span class="cm">unpackNum (List [n]) = unpackNum n</span>
<span class="cm">-}</span>
<span class="nf">unpackNum</span> <span class="n">notNum</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">TypeMismatch</span> <span class="s">"number"</span> <span class="n">notNum</span>
</pre></div>
</div>
<div class="section" id="id5">
<h4><a class="toc-backref" href="#id26">Exercise 3</a></h4>
<p>Using the same <code>typePredicate</code> function defined in Exercise 1:</p>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"symbol?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isSymbol</span><span class="p">),</span>
              <span class="o">...</span> <span class="p">]</span>

<span class="nf">isSymbol</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">List</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">Atom</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">DottedList</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>
</pre></div>
<p>Problem: <code>(symbol? '()) -&gt; #t</code> when it should be <code>#f</code>. I wonder if this is a single issue, or symptomatic of a larger problem with the function. Unfortunately I’m not familiar enough with Scheme to say.</p>
</div>
</div>
<div class="section" id="chapter-5-4">
<h3><a class="toc-backref" href="#id27">Chapter 5.4</a></h3>
<div class="section" id="id6">
<h4><a class="toc-backref" href="#id28">Exercise 1</a></h4>
<p>I changed the definition of <code>if</code> to the following (it’s one of the pattern matches
in <code>eval</code>:</p>
<div class="highlight"><pre><span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">"if"</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">conseq</span><span class="p">,</span> <span class="n">alt</span><span class="p">])</span> <span class="ow">=</span>
    <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">pred</span>
        <span class="kr">case</span> <span class="n">result</span> <span class="kr">of</span>
            <span class="kt">Bool</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">eval</span> <span class="n">alt</span>
            <span class="kt">Bool</span> <span class="kt">True</span> <span class="ow">-&gt;</span> <span class="n">eval</span> <span class="n">conseq</span>
            <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">TypeMismatch</span> <span class="s">"bool"</span> <span class="n">result</span> <span class="c1">-- Ex. 6.4.1</span>
</pre></div>
<p>This way a non-boolean value passed to <code>if</code> as a predicate causes a type error.</p>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id29">Exercise 2</a></h4>
<p>Using <code>eqv?</code> as a model, I wrote this pattern for <code>equal?</code> that compares two lists:</p>
<div class="highlight"><pre><span class="nf">equal</span> <span class="p">[(</span><span class="kt">DottedList</span> <span class="n">xs</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="kt">DottedList</span> <span class="n">ys</span> <span class="n">y</span><span class="p">)]</span> <span class="ow">=</span>
    <span class="n">equal</span> <span class="p">[</span><span class="kt">List</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="kt">List</span> <span class="o">$</span> <span class="n">ys</span> <span class="o">++</span> <span class="p">[</span><span class="n">y</span><span class="p">]]</span>

<span class="nf">equal</span> <span class="p">[</span><span class="kt">List</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">List</span> <span class="n">arg2</span><span class="p">]</span> <span class="ow">=</span> <span class="c1">-- Ex. 6.4.2</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Bool</span> <span class="o">$</span> <span class="p">((</span><span class="n">length</span> <span class="n">arg1</span> <span class="o">==</span> <span class="n">length</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="n">equalPair</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="p">))</span>
    <span class="kr">where</span> <span class="n">equalPair</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">equal</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span> <span class="kr">of</span>
                           <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
                           <span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="n">val</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span>
</pre></div>
<p>This should go before the more general pattern <code>equal [arg1, arg2]</code>.</p>
</div>
<div class="section" id="id8">
<h4><a class="toc-backref" href="#id30">Exercise 3</a></h4>
<p>This exercise is a little interesting, because <code>cond</code> and <code>case</code> are normally not Scheme primitives — they are derived from <code>if</code> using macros. But, it’s good practice, so let’s go with implementing them as primitives in Haskell. Also, we don’t have macros.</p>
<p>Beginning with <code>cond</code>. I initially implemented <code>cond</code> using a list comprehension, but had trouble throwing errors if, for instance, the statement fell through. That implementation is:</p>
<div class="highlight"><pre><span class="c1">-- This works, but invalid syntax doesn't throw errors.</span>
<span class="nf">cond</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">cond</span> <span class="n">tests</span> <span class="ow">=</span> <span class="n">eval</span> <span class="o">$</span> <span class="n">last</span> <span class="o">$</span> <span class="n">head</span> <span class="p">[</span><span class="n">exprs</span> <span class="o">|</span>
              <span class="p">(</span><span class="kt">List</span> <span class="p">(</span><span class="n">test</span><span class="kt">:</span><span class="n">exprs</span><span class="p">))</span> <span class="ow">&lt;-</span> <span class="n">tests</span><span class="p">,</span>
              <span class="kr">case</span> <span class="n">condEval</span> <span class="n">test</span> <span class="kr">of</span>
                  <span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">True</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">True</span>
                  <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="kt">False</span><span class="p">]</span>
</pre></div>
<p>The second time, I tried implementing it recursively. This is a lot cleaner. Most of the fun happens in the pattern match <code>cond ((List (test:exprs)):xs)</code>. This lets us easily extract the test for this clause, as well as the expressions to evaluate, and giving us easy access to the remaining clauses as well. But, it is also has a problem: try <code>(cond (else))</code>. Well, that should error out anyway, but the error should be caught by the evaluator.</p>
<div class="highlight"><pre><span class="nf">cond</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">cond</span> <span class="p">((</span><span class="kt">List</span> <span class="p">(</span><span class="n">test</span><span class="kt">:</span><span class="n">exprs</span><span class="p">))</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">condEval</span> <span class="n">test</span> <span class="kr">of</span>
        <span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">True</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="n">eval</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">exprs</span><span class="p">]</span>
        <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">cond</span> <span class="n">xs</span>
<span class="nf">cond</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">Default</span> <span class="s">"cond statement fell through"</span>
<span class="nf">cond</span> <span class="n">bad</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">Default</span> <span class="s">"Invalid syntax in 'cond' statement"</span>
</pre></div>
<p>Both of these implementations use a simple utility function <code>condEval</code>, that is very similar to <code>eval</code> except it also handles the <code>else</code> clause predicate.</p>
<div class="highlight"><pre><span class="nf">condEval</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">condEval</span> <span class="p">(</span><span class="kt">Atom</span> <span class="s">"else"</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">condEval</span> <span class="n">test</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">eval</span> <span class="n">test</span> <span class="kr">of</span>
    <span class="n">val</span><span class="o">@</span><span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">val</span>
    <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">TypeMismatch</span> <span class="s">"bool"</span> <span class="n">test</span>
</pre></div>
<p>Next up is <code>case</code>. we followed the same basic pattern here that we did for <code>cond</code>, since the two are similar in many ways. However, since <code>case</code> is a Haskell keyword, we name the function <code>casef</code>. Also, since the first argument to the function is special — semantically different from the following arguments — we have to wrap the recursive function in a helper. In this case the recursive function is called <code>casef'</code>.</p>
<p>Additionally, we define a fun little converter <code>boolEqv</code>, which basically calls <code>eqv</code> on its two arguments and transforms the result into a boolean. This kind of function, which is basically just there to convert values between types, seems a lot more necessary in Haskell than in the dynamic languages I’m used to (i.e. Python). On one hand, it’s a pain to have to explicitly describe the type transformations, especially when monads are involved. On the other hand, I seem to be getting better and better at doing it quickly, and once you have the conversion explicitly defined, it helps to make sure that things "just work" by forcing you to explicitly describe behavior in error cases. For instance, here if <code>eqv</code> returns an error, that is transformed into simply a False so that particular case falls through every time. Is that ideal? No, but it comes with the use of <code>any</code>. I think.</p>
<p>As a result, problem: Invalid expressions as <code>case</code> keys throw <code>case statement fell through</code> errors, not more useful errors.</p>
<div class="highlight"><pre><span class="nf">casef</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">casef</span> <span class="p">(</span><span class="n">key</span><span class="kt">:</span><span class="n">clauses</span><span class="p">)</span> <span class="ow">=</span> <span class="n">casef'</span> <span class="n">clauses</span>
    <span class="kr">where</span>
        <span class="n">casef'</span> <span class="p">((</span><span class="kt">List</span> <span class="p">(</span><span class="n">testVals</span><span class="kt">:</span><span class="n">exprs</span><span class="p">))</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">caseEval</span> <span class="n">testVals</span> <span class="p">(</span><span class="n">eval</span> <span class="n">key</span><span class="p">)</span> <span class="kr">of</span>
            <span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">True</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="n">eval</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">exprs</span><span class="p">]</span>
            <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">casef'</span> <span class="n">xs</span>
        <span class="n">casef'</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">Default</span> <span class="s">"case statement fell through"</span>
        <span class="n">casef'</span> <span class="n">bad</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">Default</span> <span class="s">"Invalid syntax in 'case' statement"</span>
<span class="nf">casef</span> <span class="n">bad</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">Default</span> <span class="s">"Invalid syntax in 'case' statement"</span>

<span class="nf">caseEval</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">caseEval</span> <span class="p">(</span><span class="kt">Atom</span> <span class="s">"else"</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">caseEval</span> <span class="p">(</span><span class="kt">List</span> <span class="n">tests</span><span class="p">)</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="kt">Bool</span> <span class="o">$</span> <span class="n">any</span> <span class="p">(</span><span class="n">boolEqv</span> <span class="n">key</span><span class="p">)</span> <span class="n">tests</span>
    <span class="kr">where</span> <span class="n">boolEqv</span> <span class="ow">::</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
          <span class="n">boolEqv</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">either</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">False</span><span class="p">)</span> <span class="n">extractBool</span> <span class="p">(</span><span class="n">eqv</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
          <span class="n">boolEqv</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">a</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
          <span class="n">extractBool</span> <span class="p">(</span><span class="kt">Bool</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div>
<p>In this exercise, we need to add the following patterns to <code>eval</code>, before the general primitive evaluator (because these primitives use special syntax):</p>
<div class="highlight"><pre><span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">((</span><span class="kt">Atom</span> <span class="s">"cond"</span><span class="p">)</span><span class="kt">:</span><span class="n">args</span><span class="p">))</span> <span class="ow">=</span> <span class="n">apply</span> <span class="s">"cond"</span> <span class="n">args</span>
<span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">((</span><span class="kt">Atom</span> <span class="s">"case"</span><span class="p">)</span><span class="kt">:</span><span class="n">args</span><span class="p">))</span> <span class="ow">=</span> <span class="n">apply</span> <span class="s">"case"</span> <span class="n">args</span>
</pre></div>
<p>Then we add them to the primitives list:</p>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"cond"</span><span class="p">,</span> <span class="n">cond</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"case"</span><span class="p">,</span> <span class="n">casef</span><span class="p">),</span>
              <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
<div class="section" id="id9">
<h4><a class="toc-backref" href="#id31">Exercise 4</a></h4>
<p>Of the string functions, we already implemented <code>string?</code>, and the string comparison operators (<code>string&lt;?</code>, <code>string=?</code>, etc.). Remaining are case-insensitive comparison operators (<code>string-ci&lt;?</code>, <code>string-ci=?</code>, etc.), <code>make-string</code>, <code>string</code>, <code>string-length</code>, <code>string-ref</code>, <code>string-set!</code>, <code>substring</code>, <code>string-append</code>, <code>string-&gt;list</code>, <code>list-&gt;string</code>, <code>string-copy</code>, and <code>string-fill!</code>. Dear Lord.</p>
<p>Let’s start with the case-insensitive comparison predicates, since they should be easy. We can leverage all the work done for the case-sensitive predicates, and just apply an intermediate function that downcases everything. In the interest of being Haskellish, I wrote it in a points-free style. Basically it unpacks the string, then lifts the Either monad off the list and maps the <code>toLower</code> function onto all the characters. Because the monad is only "lifted", not otherwise removed, we don’t need to re-add it with a <code>return</code> or anything.</p>
<div class="highlight"><pre><span class="nf">unpackStrCI</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">String</span>
<span class="nf">unpackStrCI</span> <span class="ow">=</span> <span class="p">(</span><span class="n">liftM</span> <span class="o">$</span> <span class="n">map</span> <span class="n">toLower</span><span class="p">)</span> <span class="o">.</span> <span class="n">unpackStr</span>
</pre></div>
<p>Then we can define the predicates using this new function:</p>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"string-ci=?"</span><span class="p">,</span> <span class="n">strBoolBinopCI</span> <span class="p">(</span><span class="o">==</span><span class="p">)),</span>
              <span class="p">(</span><span class="s">"string-ci&gt;?"</span><span class="p">,</span> <span class="n">strBoolBinopCI</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)),</span>
              <span class="p">(</span><span class="s">"string-ci&lt;?"</span><span class="p">,</span> <span class="n">strBoolBinopCI</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)),</span>
              <span class="p">(</span><span class="s">"string-ci&lt;=?"</span><span class="p">,</span> <span class="n">strBoolBinopCI</span> <span class="p">(</span><span class="o">&lt;=</span><span class="p">)),</span>
              <span class="p">(</span><span class="s">"string-ci&gt;=?"</span><span class="p">,</span> <span class="n">strBoolBinopCI</span> <span class="p">(</span><span class="o">&gt;=</span><span class="p">)),</span>
              <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2><a class="toc-backref" href="#id32">Conclusion</a></h2>
<p>Sorry, this is currently a <span class="caps">WIP</span> that I’m writing as I work along in the book. It should be finished eventually, though.</p>
</div>

	</div><!-- /.entry-content -->
</section>
            </div>
        </div>

		<footer>
			<p>Copyright Luke Turner 2013</p>
		</footer>
	</div>
</body>
</html>