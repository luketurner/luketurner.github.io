<!DOCTYPE html>
<html>
<head>

		
	<meta charset="utf-8">
	<title>Write Yourself a&nbsp;Scheme - Luke Turner</title>
	<meta name="author" content="Luke Turner">
	<meta name="description" content="I'm blagging behind">
	
		<link href="/theme/css/style.min.css?3f433acb" rel="stylesheet" >
	
	<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
		<script src="/theme/js/base.min.js?07bbe624" type="text/javascript"></script>





</head>
<body>
	<div id="wrapper">
		<header>
			<h1><a href="/">Luke Turner</a></h1><div id="secretnav" style="display:none;">The best weapon against an enemy is another enemy. - Nietzsche</div><a href="#" id="expander">⇉</a>

		</header>
		<div id="sidebar">

	<nav>
		<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#about" id="id8">About</a></li>
<li><a class="reference internal" href="#exercise-notes" id="id9">Exercise Notes</a><ul>
<li><a class="reference internal" href="#chapter-3-3" id="id10">Chapter 3.3</a><ul>
<li><a class="reference internal" href="#exercise-1" id="id11">Exercise 1</a></li>
<li><a class="reference internal" href="#exercise-2" id="id12">Exercise 2</a></li>
<li><a class="reference internal" href="#exercise-4" id="id13">Exercise 4</a></li>
<li><a class="reference internal" href="#exercise-5" id="id14">Exercise 5</a></li>
<li><a class="reference internal" href="#exercise-6" id="id15">Exercise 6</a></li>
<li><a class="reference internal" href="#exercise-7" id="id16">Exercise 7</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-3-4" id="id17">Chapter 3.4</a><ul>
<li><a class="reference internal" href="#id1" id="id18">Exercise 1</a></li>
<li><a class="reference internal" href="#id2" id="id19">Exercise 2</a></li>
<li><a class="reference internal" href="#exercise-3" id="id20">Exercise 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-4-3" id="id21">Chapter 4.3</a><ul>
<li><a class="reference internal" href="#id3" id="id22">Exercise 1</a></li>
<li><a class="reference internal" href="#id4" id="id23">Exercise 2</a></li>
<li><a class="reference internal" href="#id5" id="id24">Exercise 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chapter-6-4" id="id25">Chapter 6.4</a><ul>
<li><a class="reference internal" href="#id6" id="id26">Exercise 1</a></li>
<li><a class="reference internal" href="#id7" id="id27">Exercise 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion" id="id28">Conclusion</a></li>
</ul>
</div>
	</nav>
	
	


		</div>

		<div id="content">
<section id="content" class="body">
		<h2>
			<a href="/Haskell/Write%20Yourself%20a%20Scheme" rel="bookmark" title="Permalink to Write Yourself a Scheme">
				Write Yourself a&nbsp;Scheme
			</a>
		</h2>
	<div class="entry-content">
		
<div class="section" id="about">
<h2><a class="toc-backref" href="#id8">About</a></h2>
<p>Write Yourself a Scheme is an ebook available in a few places on the Web, which
walks you through writing a Scheme interpreter in Haskell.</p>
</div>
<div class="section" id="exercise-notes">
<h2><a class="toc-backref" href="#id9">Exercise Notes</a></h2>
<div class="section" id="chapter-3-3">
<h3><a class="toc-backref" href="#id10">Chapter 3.3</a></h3>
<div class="section" id="exercise-1">
<h4><a class="toc-backref" href="#id11">Exercise 1</a></h4>
<p>We’re already given a definition of parseNumber that uses monad-handling functions
to deal with the Parser monad:</p>
<div class="highlight"><pre><span class="nf">parseNumber</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">read</span><span class="p">)</span> <span class="o">$</span> <span class="n">many1</span> <span class="n">digit</span>
</pre></div>
<p>Now we’re asked to implement the same function in two additional ways:</p>
<ol class="arabic simple">
<li>Using do-notation</li>
</ol>
<div class="highlight"><pre><span class="nf">parseNumber'</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber'</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
        <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="p">(</span><span class="n">read</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
<ol class="arabic simple" start="2">
<li>Using <code>&gt;&gt;=</code>:</li>
</ol>
<div class="highlight"><pre><span class="nf">parseNumber''</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber''</span> <span class="ow">=</span> <span class="n">many1</span> <span class="n">digit</span> <span class="o">&gt;&gt;=</span>
                                <span class="nf">\</span><span class="n">str</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">read</span><span class="p">)</span> <span class="n">str</span>
</pre></div>
</div>
<div class="section" id="exercise-2">
<h4><a class="toc-backref" href="#id12">Exercise 2</a></h4>
<p>One possible string parser is the following:</p>
<div class="highlight"><pre><span class="nf">parseString</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseString</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">char</span> <span class="sc">'"'</span>
                 <span class="n">str</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="n">chr</span>
                 <span class="n">char</span> <span class="sc">'"'</span>
                 <span class="n">return</span> <span class="o">$</span> <span class="kt">String</span> <span class="n">str</span>
              <span class="kr">where</span> <span class="n">chr</span> <span class="ow">=</span> <span class="n">try</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'</span><span class="se">\\</span><span class="sc">'</span> <span class="o">&gt;&gt;</span> <span class="n">oneOf</span> <span class="s">"</span><span class="se">\\\"</span><span class="s">"</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">noneOf</span> <span class="s">"</span><span class="se">\"</span><span class="s">"</span>
</pre></div>
</div>
<div class="section" id="exercise-4">
<h4><a class="toc-backref" href="#id13">Exercise 4</a></h4>
<div class="highlight"><pre><span class="nf">parseNumber</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseNumber</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">base</span> <span class="ow">&lt;-</span> <span class="n">parseNumericPrefix</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">base</span> <span class="kr">of</span>
        <span class="n">'h'</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">hexDigit</span>
        <span class="n">'o'</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">octDigit</span>
        <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">notFollowedBy</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'.'</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="p">(</span><span class="n">readBase</span> <span class="n">base</span><span class="p">))</span> <span class="n">x</span>
    <span class="kr">where</span> <span class="n">readBase</span> <span class="n">'d'</span> <span class="ow">=</span> <span class="n">readDec</span>
          <span class="n">readBase</span> <span class="n">'o'</span> <span class="ow">=</span> <span class="n">readOct</span>
          <span class="n">readBase</span> <span class="n">'h'</span> <span class="ow">=</span> <span class="n">readHex</span>
</pre></div>
</div>
<div class="section" id="exercise-5">
<h4><a class="toc-backref" href="#id14">Exercise 5</a></h4>
<div class="highlight"><pre><span class="nf">parseChar</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseChar</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">char</span> <span class="sc">'#'</span>
    <span class="n">char</span> <span class="sc">'</span><span class="se">\\</span><span class="sc">'</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"space"</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="sc">' '</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="n">try</span> <span class="p">(</span><span class="n">string</span> <span class="s">"newline"</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="sc">'</span><span class="se">\n</span><span class="sc">'</span><span class="p">)</span>
        <span class="o">&lt;|&gt;</span> <span class="n">alphaNum</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Char</span> <span class="n">c</span>
</pre></div>
<p>When we add this to parseExpr, we need to be careful, because now we have two things that start with <code>#</code>: parseNumber (e.g. <code>#d123</code>) and parseChar (e.g. <code>#\a</code>) Instead of left-factoring, (A future exercise has us left-factoring the grammar) I’ve used the <code>try</code> function in <code>parseExpr</code>. That way we can "try" to see if the expression is a number; if it’s not, we don’t consume any input.</p>
</div>
<div class="section" id="exercise-6">
<h4><a class="toc-backref" href="#id15">Exercise 6</a></h4>
<div class="highlight"><pre><span class="nf">parseFloat</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseFloat</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">whole</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'.'</span>
    <span class="n">part</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">exp</span> <span class="ow">&lt;-</span> <span class="n">option</span> <span class="s">"0"</span> <span class="p">(</span><span class="n">oneOf</span> <span class="s">"eE"</span> <span class="o">&gt;&gt;</span> <span class="n">many1</span> <span class="n">digit</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">num</span> <span class="ow">=</span> <span class="n">whole</span> <span class="o">++</span> <span class="s">"."</span> <span class="o">++</span> <span class="n">part</span> <span class="o">++</span> <span class="s">"e"</span> <span class="o">++</span> <span class="n">exp</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Float</span> <span class="o">.</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">readFloat</span><span class="p">)</span> <span class="n">num</span>
</pre></div>
<p>The main interesting thing here is the line <code>exp &lt;- option "0" (oneOf "eE" &gt;&gt; many1 digit)</code>. This sets <code>exp</code> to the value of the number following the e, with 0 as the default.</p>
</div>
<div class="section" id="exercise-7">
<h4><a class="toc-backref" href="#id16">Exercise 7</a></h4>
<div class="highlight"><pre><span class="nf">parseRational</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseRational</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">top</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'/'</span>
    <span class="n">bot</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Ratio</span> <span class="p">((</span><span class="n">read</span> <span class="n">top</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">read</span> <span class="n">bot</span><span class="p">))</span>


<span class="c1">-- <span class="caps">TODO</span> fix support for decimals</span>
<span class="nf">parseComplex</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseComplex</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">real</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="sc">'+'</span>
    <span class="n">imag</span> <span class="ow">&lt;-</span> <span class="n">many1</span> <span class="n">digit</span>
    <span class="n">char</span> <span class="n">'i'</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="kt">Complex</span> <span class="o">.</span> <span class="kt">Couble</span><span class="p">)</span> <span class="p">((</span><span class="n">read</span> <span class="n">real</span><span class="p">)</span> <span class="kt">:+</span> <span class="p">(</span><span class="n">read</span> <span class="n">imag</span><span class="p">))</span>
</pre></div>
<p>My Complex implementation leaves a bit to be desired — it can only handle whole-number parts. The <code>Couble</code> type constructor is a "wrapper" around Complex Double, defined like so:</p>
<div class="highlight"><pre><span class="kr">data</span> <span class="kt">Couble</span> <span class="ow">=</span> <span class="kt">Couble</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kt">Double</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Eq</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">LispVal</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="kt">String</span>
               <span class="o">...</span>
             <span class="o">|</span> <span class="kt">Complex</span> <span class="kt">Couble</span>
</pre></div>
<p>We only need to derive <code>Eq</code> once we get into chapter 6 or thereabouts.</p>
</div>
</div>
<div class="section" id="chapter-3-4">
<h3><a class="toc-backref" href="#id17">Chapter 3.4</a></h3>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id18">Exercise 1</a></h4>
<div class="highlight"><pre><span class="c1">-- handles `</span>
<span class="nf">parseBackquoted</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseBackquoted</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">char</span> <span class="sc">'`'</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">parseExpr</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">"quasiquote"</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

<span class="c1">-- handles , and ,@</span>
<span class="nf">parseUnquote</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
<span class="nf">parseUnquote</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">style</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="p">(</span><span class="n">char</span> <span class="sc">','</span> <span class="o">&gt;&gt;</span> <span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">','</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">parseExpr</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="p">(</span><span class="n">descriptor</span> <span class="n">style</span><span class="p">),</span> <span class="n">x</span><span class="p">]</span>
    <span class="kr">where</span> <span class="n">descriptor</span> <span class="sc">','</span> <span class="ow">=</span> <span class="s">"unquote"</span>
      <span class="n">descriptor</span> <span class="sc">'@'</span> <span class="ow">=</span> <span class="s">"unquote-list"</span>
</pre></div>
<p>Once again, too lazy to left-factor the grammar. I use pattern matching to check the value of <code>style</code>, which contains either <code>@</code> or <code>,</code>.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id19">Exercise 2</a></h4>
<p>I haven’t done this yet.</p>
</div>
<div class="section" id="exercise-3">
<h4><a class="toc-backref" href="#id20">Exercise 3</a></h4>
<p>I haven’t done this yet either.</p>
</div>
</div>
<div class="section" id="chapter-4-3">
<h3><a class="toc-backref" href="#id21">Chapter 4.3</a></h3>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id22">Exercise 1</a></h4>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"string?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isString</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"number?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isNumber</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"bool?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isBool</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"real?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isReal</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"char?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isChar</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"ratio?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isRational</span><span class="p">),</span>
              <span class="p">(</span><span class="s">"complex?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isComplex</span><span class="p">),</span>
              <span class="o">...</span> <span class="p">]</span>

<span class="nf">typePredicate</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">LispVal</span>
<span class="nf">typePredicate</span> <span class="n">op</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="n">op</span> <span class="n">val</span>
<span class="nf">typePredicate</span> <span class="n">op</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">NumArgs</span> <span class="mi">1</span> <span class="n">vals</span>

<span class="nf">isBool</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isBool</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isBool</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isString</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isString</span> <span class="p">(</span><span class="kt">String</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isString</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isChar</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isChar</span> <span class="p">(</span><span class="kt">Char</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isChar</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isNumber</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Float</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isNumber</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isReal</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Float</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isReal</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isRational</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isRational</span> <span class="p">(</span><span class="kt">Ratio</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isRational</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isRational</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>

<span class="nf">isComplex</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="c1">-- (not true as long as parseComplex only allows whole numbers...)</span>
<span class="c1">-- isComplex (Float _) = Bool True</span>
<span class="nf">isComplex</span> <span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isComplex</span> <span class="p">(</span><span class="kt">Complex</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isComplex</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>
</pre></div>
<p>There are a few ways to approach this exercise… but I prefer explicitly listing the matches, because it helps in cases like isNumber, where different type constructors all indicate valid numbers.</p>
</div>
<div class="section" id="id4">
<h4><a class="toc-backref" href="#id23">Exercise 2</a></h4>
<p>Just comment out the pattern matches indicated in the exercise:</p>
<div class="highlight"><pre><span class="nf">unpackNum</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">ThrowsError</span> <span class="kt">Integer</span>
<span class="nf">unpackNum</span> <span class="p">(</span><span class="kt">Number</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">n</span>
<span class="cm">{- Removed per Ex. 4.3 #2</span>
<span class="cm">unpackNum (String n) = let parsed = reads n in</span>
<span class="cm">                          if null parsed</span>
<span class="cm">                            then throwError $ TypeMismatch "number" $ String n</span>
<span class="cm">                            else return $ fst $ parsed !! 0</span>
<span class="cm">unpackNum (List [n]) = unpackNum n</span>
<span class="cm">-}</span>
<span class="nf">unpackNum</span> <span class="n">notNum</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">TypeMismatch</span> <span class="s">"number"</span> <span class="n">notNum</span>
</pre></div>
</div>
<div class="section" id="id5">
<h4><a class="toc-backref" href="#id24">Exercise 3</a></h4>
<p>Using the same <code>typePredicate</code> function defined in Exercise 1:</p>
<div class="highlight"><pre><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[</span> <span class="o">...</span>
              <span class="p">(</span><span class="s">"symbol?"</span><span class="p">,</span> <span class="n">typePredicate</span> <span class="n">isSymbol</span><span class="p">),</span>
              <span class="o">...</span> <span class="p">]</span>

<span class="nf">isSymbol</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">List</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">Atom</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="p">(</span><span class="kt">DottedList</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">True</span>
<span class="nf">isSymbol</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="kt">False</span>
</pre></div>
<p>Problem: <code>(symbol? '()) -&gt; #t</code> when it should be <code>#f</code>.</p>
</div>
</div>
<div class="section" id="chapter-6-4">
<h3><a class="toc-backref" href="#id25">Chapter 6.4</a></h3>
<div class="section" id="id6">
<h4><a class="toc-backref" href="#id26">Exercise 1</a></h4>
<p>I changed the definition of <code>if</code> to the following (it’s one of the pattern matches
in <code>eval</code>:</p>
<div class="highlight"><pre><span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">"if"</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">conseq</span><span class="p">,</span> <span class="n">alt</span><span class="p">])</span> <span class="ow">=</span>
    <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">pred</span>
        <span class="kr">case</span> <span class="n">result</span> <span class="kr">of</span>
            <span class="kt">Bool</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">eval</span> <span class="n">alt</span>
            <span class="kt">Bool</span> <span class="kt">True</span> <span class="ow">-&gt;</span> <span class="n">eval</span> <span class="n">conseq</span>
            <span class="n">otherwise</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="o">$</span> <span class="kt">TypeMismatch</span> <span class="s">"bool"</span> <span class="n">result</span> <span class="c1">-- Ex. 6.4.1</span>
</pre></div>
<p>This way a non-boolean value passed to <code>if</code> as a predicate causes a type error.</p>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id27">Exercise 2</a></h4>
<p>Using <code>eqv?</code> as a model, I wrote this pattern for <code>equal?</code> that compares two lists:</p>
<div class="highlight"><pre><span class="nf">equal</span> <span class="p">[(</span><span class="kt">DottedList</span> <span class="n">xs</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="kt">DottedList</span> <span class="n">ys</span> <span class="n">y</span><span class="p">)]</span> <span class="ow">=</span>
    <span class="n">equal</span> <span class="p">[</span><span class="kt">List</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="kt">List</span> <span class="o">$</span> <span class="n">ys</span> <span class="o">++</span> <span class="p">[</span><span class="n">y</span><span class="p">]]</span>

<span class="nf">equal</span> <span class="p">[</span><span class="kt">List</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">List</span> <span class="n">arg2</span><span class="p">]</span> <span class="ow">=</span> <span class="c1">-- Ex. 6.4.2</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Bool</span> <span class="o">$</span> <span class="p">((</span><span class="n">length</span> <span class="n">arg1</span> <span class="o">==</span> <span class="n">length</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="n">equalPair</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">arg1</span> <span class="n">arg2</span> <span class="p">))</span>
    <span class="kr">where</span> <span class="n">equalPair</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">equal</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span> <span class="kr">of</span>
                           <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
                           <span class="kt">Right</span> <span class="p">(</span><span class="kt">Bool</span> <span class="n">val</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span>
</pre></div>
<p>This should go before the more general pattern <code>equal [arg1, arg2]</code>.</p>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2><a class="toc-backref" href="#id28">Conclusion</a></h2>
<p>Sorry, this is currently a <span class="caps">WIP</span> that I’m writing as I work along in the book. It should be finished eventually, though.</p>
</div>

	</div><!-- /.entry-content -->
</section>
		</div>

		<footer>
			<p>Copyright Luke Turner 2013</p>
		</footer>
	</div>
</body>
</html>